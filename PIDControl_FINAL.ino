// Find min and max compare register values to get 1 ms to 2 ms pulse
// Using 16-bit timer with prescale of 8
// Register value should be number of clock cycles before reset - 1 b/c we count up from 0

/*
The range is calculated using a formula for counts. The units are in microseconds.
Our period is 2,000,000 counts.
  From the setup, TCCR1B_pre |= _BV(CS11), sets the prescaler to 8.
  Since there is a 16Mhz clock, the counts is 16M / 8 = 2M, giving us 2,000,000 counts.
OCR1A = 39999; gives us 50hz frequency. This is 2,000,000 / 50 - 1
Then we set the counts for the time high every cycle.
  My servo has a pwm range of 0.5ms to 2.5ms corresponding to 0 degrees and 180 degrees.
    0.5ms => 2,000,000 * 0.0005 => 1000 counts
    2.5ms => 2,000,000 * 0.0025 => 5000 counts
*/

/* 
  This RC Car has a pwm range of 1.4ms to 1.7ms 
    1.4ms => 2,000,000 * 0.0014 => 2800 counts
    1.7ms => 2,000,000 * 0.0017 => 3400 counts
*/

int OCR1B_min = 2800;
int OCR1B_max = 3400;

// ref: https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/
// forum on Arduino PWM: https://forum.arduino.cc/index.php?topic=354160.0
// Schematic: https://content.arduino.cc/assets/UNO-TH_Rev3e_sch.pdf

float desiredLinearVelocity = 2.00;

// Hall-Effect Sensors
const int phaseAPin = 2; // Digital pin connected to Phase A
const int phaseBPin = 4; // Digital pin connected to Phase B
const int phaseCPin = 5; // Digital pin connected to Phase C

// Measurements and Gear Ratios
const float radius = 0.03; // Radius of the wheel/pulley in meters, adjust if needed
const float degreesPerPulse = 120.0; // Degrees per pulse for a 2-pole motor
const float gearRatio = 64.0 / 27.0;  // Gear ratio 64/27 (64 teeth on big gear / 27 teeth on small gear)
const float wheelShaftRatio = 75.0 / 30.0; // Ratio between how much shaft spins to how much wheels spin

// Calculate Angular Velocities
volatile int currentState = 0;
volatile int lastState = 0;
unsigned long lastTime = 0;
float motorSpeed = 0;  // Motor speed in RPM (before gear ratio adjustment)
float shaftSpeed = 0; // Output speed in RPM (after gear ratio adjustment)
float wheelAngularVelocity = 0; // Angular velocity in rad/s 
float wheelLinearVelocity = 0; // Linear velocity in m/s 

unsigned long timeDiff = 0;

// Moving Average
int counter = 0;
float averageLinearVelocity = 0;
float averageShaftSpeed = 0;
const int movingAverageSize = 100;  // Adjust the size of the moving average window as needed
float linearVelocityBuffer[movingAverageSize];
float shaftSpeedBuffer[movingAverageSize];
int bufferIndex = 0;

// PID variables
int OCR1B_min_pid = 0;
float kp = 15.0;   // Proportional gain
float ki = 0.05;  // Integral gain
float kd = 10.0;  // Derivative gain  
float error = 0;
float previousError = 0;
float integral = 0;
float derivative = 0;
float output = 0;

void setup() {
  // put your setup code here, to run once:
    Serial.begin(115200); // Start serial communication at 115200 bps

  // Set timer output pin data direction
  // From ATMEGA328/P datasheet pgs 13 and 14 and the UNO schematic
  // OC1B -> PB2 -> MCU Pin 16 -> Board Pin 10
  // pg 167: Actual OC1x value will only be visible if data direction for the port pin is set as output (DDR_OC1x)
  // can use 3, 5, 6, 9, 10, or 11 on most Arduinos

  pinMode(10, OUTPUT);

  // Create variables to store the values to be written to the TIM1 registers
  // Control registers are 8 bits (char)
  char TCCR1A_pre = 0x00; 
  char TCCR1B_pre = 0x00;

  // Set OC1B to non-inverting mode
  // pg 167: INCORRECT INFO: Non-inverted  PWM output can be generated by writing the COM1x[1:0] to 0x3
  // pg 174-175: looks like it is actually 0x2 in register description
  // Below code was tested working
  TCCR1A_pre |= _BV(COM1B1);

  // Set waveform generation mode
  // pg 165: counter is incremented until counter value matches value in OCR1A (WGM1[3:0]=0xF)
  // pg 175: WGM1[3:2] bits found in TCCR1B register, WGM1[1:0] found in TCCR1A register
  TCCR1B_pre |= _BV(WGM13) | _BV(WGM12);
  TCCR1A_pre |= _BV(WGM11) | _BV(WGM10);

  // Select the prescaled clock to use.  See Excel worksheet "PWMCalcs" to see justification.
  TCCR1B_pre |= _BV(CS11);

  // Write control registers
  TCCR1A = TCCR1A_pre;
  TCCR1B = TCCR1B_pre;

  // Write output compare registers (2 bytes)
  // pg 167: f_OCnxPWM = f_CLK_IO / (N*(1+TOP))
  OCR1A = 39999; // To get 50 Hz frequency
  OCR1B = OCR1B_min; // start at 1 ms pulse width

  pinMode(phaseAPin, INPUT_PULLUP); // Set Phase A pin as input with pull-up
  pinMode(phaseBPin, INPUT_PULLUP); // Set Phase B pin as input with pull-up
  pinMode(phaseCPin, INPUT_PULLUP); // Set Phase C pin as input with pull-up

  // Attach interrupts to the Hall sensor pins
  attachInterrupt(digitalPinToInterrupt(phaseAPin), updateState, CHANGE);
  attachInterrupt(digitalPinToInterrupt(phaseBPin), updateState, CHANGE);
  attachInterrupt(digitalPinToInterrupt(phaseCPin), updateState, CHANGE);

  lastTime = micros(); // Initialize time
}

void loop() {
  // put your main code here, to run repeatedly:

  // Measure current motor speed (wheelSpeed) and calculate error
  error = desiredLinearVelocity - averageLinearVelocity;

  // Calculate PID terms
  integral += error;
  derivative = error - previousError;

  // Compute PID output
  output = kp * error + ki * integral + kd * derivative;
  OCR1B += output;
  OCR1B = constrain(OCR1B, OCR1B_min, OCR1B_max);
  // error tells you how far you are from ideal or desired control
  // Proportional: Take a proportion of how far off you are
  // Integral: Sum all errors overtime and make a nudge in the correct direction
  // Derivative: Make nudges based on how far off you far. Off by a lot => heavier change. Off by a little => less change
  // Output is sum of p, i, d. I want to add the output to OCR1B and stay within bounds of 2900-4000

  // Update previous error for next iteration
  previousError = error;

  delay(1000);

  Serial.print("averageLinearVelocity:"); Serial.println(averageLinearVelocity);
  Serial.print("neutralization:"); Serial.println(OCR1B);
  /*
  In your original code, you have:
  OCR1B = map(potVal, 0, 1023, OCR1B_min_pid, OCR1B_max);

  Since you are not using a potentiometer anymore, you assume A0 is always 0.
  The map function maps the potentiometer value on the range [0, 1023], to the range [OCR1B_min_pid, OCR1B_max].
  This is just asking for problems when A0 may be unstable.
  */
}

void updateState() {
  static unsigned long lastDebounceTime = 0;
  static int lastA = LOW, lastB = LOW, lastC = LOW;
  unsigned long currentMillis = millis();

  // Debounce logic with a longer debounce time (adjust as necessary)
  if (currentMillis - lastDebounceTime > 0.5) {
    int phaseA = digitalRead(phaseAPin);
    int phaseB = digitalRead(phaseBPin);
    int phaseC = digitalRead(phaseCPin);

    if ((phaseA != lastA) || (phaseB != lastB) || (phaseC != lastC)) {
      lastDebounceTime = currentMillis;
      lastA = phaseA;
      lastB = phaseB;
      lastC = phaseC;

      currentState = (phaseA << 2) | (phaseB << 1) | phaseC;

      unsigned long currentTime = micros();
      timeDiff = currentTime - lastTime;

      // Handle timer overflow
      if (timeDiff < 0) {
        timeDiff = (4294967295 - lastTime) + currentTime + 1;
      }

      if (timeDiff > 0) {
        float degreesPerSecond = (degreesPerPulse / (timeDiff / 1000000.0)); // [degrees / s]
        float angularVelocityMotor = degreesPerSecond * (PI / 180.0); // [rad / s]

        motorSpeed = (60 * degreesPerSecond) / 360.0; // Motor speed in RPM (before gear ratio)
        shaftSpeed = motorSpeed / gearRatio; // Output speed in RPM (after gear ratio)
        
        wheelAngularVelocity = shaftSpeed / wheelShaftRatio; // [RPM]
        wheelLinearVelocity = (wheelAngularVelocity * radius * 2 * PI) / 60; // Linear velocity (m/s)

        // Update moving average buffers
        linearVelocityBuffer[bufferIndex] = wheelLinearVelocity;
        shaftSpeedBuffer[bufferIndex] = shaftSpeed;

        bufferIndex = (bufferIndex + 1) % movingAverageSize;

        // Calculate SMA for linear velocity and shaft speed
        float sumLinearVelocity = 0;
        float sumShaftSpeed = 0;

        counter++;
        if (counter == 100) {
          counter = 0;
          for (int i = 0; i < movingAverageSize; ++i) {
            sumLinearVelocity += linearVelocityBuffer[i];
            sumShaftSpeed += shaftSpeedBuffer[i];
          }
          averageLinearVelocity = sumLinearVelocity / movingAverageSize;
          averageShaftSpeed = sumShaftSpeed / movingAverageSize;
          // Serial.print("Linear Velocity: "); Serial.println(averageLinearVelocity);
          // Serial.print("Shaft Speed: "); Serial.println(averageShaftSpeed);
        }

        // Debug output (uncomment for detailed logs)
        // Serial.println("<<<<<<<<<<<<");
        // Serial.print("Phase A: "); Serial.print(phaseA);
        // Serial.print(", Phase B: "); Serial.print(phaseB);
        // Serial.print(", Phase C: "); Serial.println(phaseC);
        // Serial.print("Current State: "); Serial.println(currentState, BIN);
        // Serial.print("Time Diff: "); Serial.println(timeDiff);
        // Serial.print("Motor Speed: "); Serial.print(motorSpeed);
        // Serial.print(" RPM, Output Speed: "); Serial.print(outputSpeed);
        // Serial.println(" RPM"); 
        // Serial.print("Linear Velocity: "); Serial.print(linearVelocity);
        // Serial.println(" m/s");
      }

      lastTime = currentTime;
      lastState = currentState;
    }
  }
}

// 1: GND
// 2: HE #1
// 3: HE #2
// 4: HE #3 
// 5: Temp Sensor
// 6: 5V

// Around 1m/s - 10 m/s is range of velocity
