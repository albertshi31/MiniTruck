// Find min and max compare register values to get 1 ms to 2 ms pulse
// Using 16-bit timer with prescale of 8
// Register value should be number of clock cycles before reset - 1 b/c we count up from 0

/*
The range is calculated using a formula for counts. The units are in microseconds.
Our period is 2,000,000 counts.
  From the setup, TCCR1B_pre |= _BV(CS11), sets the prescaler to 8.
  Since there is a 16Mhz clock, the counts is 16M / 8 = 2M, giving us 2,000,000 counts.
OCR1A = 39999; gives us 50hz frequency. This is 2,000,000 / 50 - 1
Then we set the counts for the time high every cycle.
  My servo has a pwm range of 0.5ms to 2.5ms corresponding to 0 degrees and 180 degrees.
    0.5ms => 2,000,000 * 0.0005 => 1000 counts
    2.5ms => 2,000,000 * 0.0025 => 5000 counts
*/

/* 
  This RC Car has a pwm range of 1.4ms to 1.7ms 
    1.4ms => 2,000,000 * 0.0014 => 2800 counts
    1.7ms => 2,000,000 * 0.0017 => 3400 counts
*/

long OCR1B_min = 2750;
long OCR1B_max = 3400;

// ref: https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/
// forum on Arduino PWM: https://forum.arduino.cc/index.php?topic=354160.0
// Schematic: https://content.arduino.cc/assets/UNO-TH_Rev3e_sch.pdf

float desiredLinearVelocity = 1.00;

// Hall-Effect Sensors
const int phaseAPin = 2; // Digital pin connected to Phase A
const int phaseBPin = 4; // Digital pin connected to Phase B
const int phaseCPin = 5; // Digital pin connected to Phase C

// Measurements and Gear Ratios
const float radius = 0.03; // Radius of the wheel/pulley in meters, adjust if needed
const float degreesPerPulse = 120.0; // Degrees per pulse for a 2-pole motor
const float gearRatio = 64.0 / 27.0;  // Gear ratio 64/27 (64 teeth on big gear / 27 teeth on small gear)
const float wheelShaftRatio = 75.0 / 30.0; // Ratio between how much shaft spins to how much wheels spin

// Calculate Angular Velocities
volatile int currentState = 0;
volatile int lastState = 0;
unsigned long lastTime = 0;
float motorSpeed = 0;  // Motor speed in RPM (before gear ratio adjustment)
float shaftSpeed = 0; // Output speed in RPM (after gear ratio adjustment)
float wheelAngularVelocity = 0; // Angular velocity in rad/s 
float wheelLinearVelocity = 0; // Linear velocity in m/s 

unsigned long timeDiff = 0;

// Moving Average
int counter = 0;
int counterThrottle = 0;
float averageLinearVelocity = 0;
float averageShaftSpeed = 0;
const int movingAverageSize = 100;  // Adjust the size of the moving average window as needed
float linearVelocityBuffer[movingAverageSize];
float shaftSpeedBuffer[movingAverageSize];
int bufferIndex = 0;

// PID variables
float kp = 7.0;   // Proportional gain
float ki = 0.015;  // Integral gain
float kd = 4.0;  // Derivative gain  
float error = 0;
float previousError = 0;
float integral = 0;
float derivative = 0;
float output = 0;

const int inputPinAux = 11;
const int inputPinThr = 3;

unsigned long start_time = 0;
bool timer_started = false;
bool PID_control = false;
float PID_error = 0.07;

unsigned long highTimeThr = 0;
unsigned long prevThr = 0;

volatile signed long prev_time = 0; // To store the time of the previous edge
volatile signed long pulse_width = 0; // To store the width of the PWM pulse

long minThrottle = 1400;
long maxThrottle = 1700;

void setup() {
  Serial.begin(115200); // Start serial communication at 115200 bps

  // Set timer output pin data direction
  // From ATMEGA328/P datasheet pgs 13 and 14 and the UNO schematic
  // OC1B -> PB2 -> MCU Pin 16 -> Board Pin 10
  // pg 167: Actual OC1x value will only be visible if data direction for the port pin is set as output (DDR_OC1x)
  // can use 3, 5, 6, 9, 10, or 11 on most Arduinos

  pinMode(3, INPUT);
  pinMode(10, OUTPUT);

  // Create variables to store the values to be written to the TIM1 registers
  // Control registers are 8 bits (char)
  char TCCR1A_pre = 0x00; 
  char TCCR1B_pre = 0x00;

  // Set OC1B to non-inverting mode
  // pg 167: INCORRECT INFO: Non-inverted  PWM output can be generated by writing the COM1x[1:0] to 0x3
  // pg 174-175: looks like it is actually 0x2 in register description
  // Below code was tested working
  TCCR1A_pre |= _BV(COM1B1);

  // Set waveform generation mode
  // pg 165: counter is incremented until counter value matches value in OCR1A (WGM1[3:0]=0xF)
  // pg 175: WGM1[3:2] bits found in TCCR1B register, WGM1[1:0] found in TCCR1A register
  TCCR1B_pre |= _BV(WGM13) | _BV(WGM12);
  TCCR1A_pre |= _BV(WGM11) | _BV(WGM10);

  // Select the prescaled clock to use.  See Excel worksheet "PWMCalcs" to see justification.
  TCCR1B_pre |= _BV(CS11);

  // Write control registers
  TCCR1A = TCCR1A_pre;
  TCCR1B = TCCR1B_pre;

  // Write output compare registers (2 bytes)
  // pg 167: f_OCnxPWM = f_CLK_IO / (N*(1+TOP))
  OCR1A = 39999; // To get 50 Hz frequency
  OCR1B = OCR1B_min; // start at 1 ms pulse width

  pinMode(phaseAPin, INPUT_PULLUP); // Set Phase A pin as input with pull-up
  pinMode(phaseBPin, INPUT_PULLUP); // Set Phase B pin as input with pull-up
  pinMode(phaseCPin, INPUT_PULLUP); // Set Phase C pin as input with pull-up

  // Attach interrupts to the Hall sensor pins
  attachInterrupt(digitalPinToInterrupt(phaseAPin), updateState, CHANGE);
  attachInterrupt(digitalPinToInterrupt(phaseBPin), updateState, CHANGE);
  attachInterrupt(digitalPinToInterrupt(phaseCPin), updateState, CHANGE);

  attachInterrupt(digitalPinToInterrupt(inputPinThr), rising, RISING); // Attach interrupt to pin 3 for rising edges
  
  lastTime = micros(); // Initialize time
}

void updateState() {
  static unsigned long lastDebounceTime = 0;
  static int lastA = LOW, lastB = LOW, lastC = LOW;
  unsigned long currentMillis = millis();

  // Debounce logic with a longer debounce time (adjust as necessary)
  if (currentMillis - lastDebounceTime > 0.5) {
    int phaseA = digitalRead(phaseAPin);
    int phaseB = digitalRead(phaseBPin);
    int phaseC = digitalRead(phaseCPin);

    if ((phaseA != lastA) || (phaseB != lastB) || (phaseC != lastC)) {
      lastDebounceTime = currentMillis;
      lastA = phaseA;
      lastB = phaseB;
      lastC = phaseC;

      currentState = (phaseA << 2) | (phaseB << 1) | phaseC;

      unsigned long currentTime = micros();
      timeDiff = currentTime - lastTime;

      // Handle timer overflow
      if (timeDiff < 0) {
        timeDiff = (4294967295 - lastTime) + currentTime + 1;
      }

      if (timeDiff > 0) {
        float degreesPerSecond = (degreesPerPulse / (timeDiff / 1000000.0)); // [degrees / s]
        float angularVelocityMotor = degreesPerSecond * (PI / 180.0); // [rad / s]

        motorSpeed = (60 * degreesPerSecond) / 360.0; // Motor speed in RPM (before gear ratio)
        shaftSpeed = motorSpeed / gearRatio; // Output speed in RPM (after gear ratio)
        
        wheelAngularVelocity = shaftSpeed / wheelShaftRatio; // [RPM]
        wheelLinearVelocity = (wheelAngularVelocity * radius * 2 * PI) / 60; // Linear velocity (m/s)

        // Update moving average buffers
        linearVelocityBuffer[bufferIndex] = wheelLinearVelocity;
        shaftSpeedBuffer[bufferIndex] = shaftSpeed;

        bufferIndex = (bufferIndex + 1) % movingAverageSize;

        // Calculate SMA for linear velocity and shaft speed
        float sumLinearVelocity = 0;
        float sumShaftSpeed = 0;

        counter++;
        if (counter == movingAverageSize) {
          counter = 0;
          for (int i = 0; i < movingAverageSize; ++i) {
            sumLinearVelocity += linearVelocityBuffer[i];
            sumShaftSpeed += shaftSpeedBuffer[i];
          }
          averageLinearVelocity = sumLinearVelocity / movingAverageSize;
          averageShaftSpeed = sumShaftSpeed / movingAverageSize;
          // Serial.print("Linear Velocity: "); Serial.println(averageLinearVelocity);
          // Serial.print("Shaft Speed: "); Serial.println(averageShaftSpeed);
        }

        // Debug output (uncomment for detailed logs)
        // Serial.println("<<<<<<<<<<<<");
        // Serial.print("Phase A: "); Serial.print(phaseA);
        // Serial.print(", Phase B: "); Serial.print(phaseB);
        // Serial.print(", Phase C: "); Serial.println(phaseC);
        // Serial.print("Current State: "); Serial.println(currentState, BIN);
        // Serial.print("Time Diff: "); Serial.println(timeDiff);
        // Serial.print("Motor Speed: "); Serial.print(motorSpeed);
        // Serial.print(" RPM, Output Speed: "); Serial.print(outputSpeed);
        // Serial.println(" RPM"); 
        // Serial.print("Linear Velocity: "); Serial.print(linearVelocity);
        // Serial.println(" m/s");
      }

      lastTime = currentTime;
      lastState = currentState;
    }
  }
}

void resetPID() {
  integral = 0;
  previousError = 0;
  error = 0;
  derivative = 0;
  counter = 0;
  bufferIndex = 0;

  for (int i = 0; i < movingAverageSize; i++) {
    linearVelocityBuffer[i] = 0;
    shaftSpeedBuffer[i] = 0;
  }

  averageLinearVelocity = 0;
  averageShaftSpeed = 0;
  OCR1B = OCR1B_min;
}

void rising() {
  unsigned long current_time = micros(); // Record the current time at the rising edge
  prev_time = current_time; // Store the time of the rising edge
  attachInterrupt(digitalPinToInterrupt(inputPinThr), falling, FALLING); // Reattach interrupt for falling edge
}

void falling() {
  unsigned long current_time = micros(); // Record the current time at the falling edge
  pulse_width = current_time - prev_time; // Calculate the pulse width
  pulse_width = constrain(pulse_width, minThrottle, maxThrottle);
  attachInterrupt(digitalPinToInterrupt(inputPinThr), rising, RISING); // Reattach interrupt for rising edge
}

void loop() {
  // put your main code here, to run repeatedly:

  unsigned long highTimeAux = pulseIn(inputPinAux, HIGH);

  if (pulse_width > 0) {
    // Serial.print("Pulse width: ");
    // Serial.print(pulse_width);
    // Serial.println(" microseconds");
  }

  if (!PID_control) {
    // Serial.print("highTimeAux: "); Serial.println(highTimeAux);
    averageLinearVelocity = 0;
  }

  if (highTimeAux > 1080 && highTimeAux < 1086 || PID_control == true) {
    PID_control = true;

    // Measure current motor speed (wheelSpeed) and calculate error
    error = desiredLinearVelocity - averageLinearVelocity;

    // Calculate PID terms
    integral += error;
    derivative = error - previousError;

    // Compute PID output
    output = kp * error + ki * integral + kd * derivative;
    OCR1B += output;
    OCR1B = constrain(OCR1B, OCR1B_min, OCR1B_max);
    // error tells you how far you are from ideal or desired control
    // Proportional: Take a proportion of how far off you are
    // Integral: Sum all errors overtime and make a nudge in the correct direction
    // Derivative: Make nudges based on how far off you far. Off by a lot => heavier change. Off by a little => less change
    // Output is sum of p, i, d. I want to add the output to OCR1B and stay within bounds of 2900-4000

    // Update previous error for next iteration
    previousError = error;

    delay(100);

    Serial.print("averageLinearVelocity:"); Serial.println(averageLinearVelocity);
    Serial.print("OCR1B:"); Serial.println(OCR1B);
    /*
    In your original code, you have:
    OCR1B = map(potVal, 0, 1023, OCR1B_min_pid, OCR1B_max);

    Since you are not using a potentiometer anymore, you assume A0 is always 0.
    The map function maps the potentiometer value on the range [0, 1023], to the range [OCR1B_min_pid, OCR1B_max].
    This is just asking for problems when A0 may be unstable.
    */

    // Around 1m/s - 10 m/s is range of velocity
    if (abs(error) < PID_error) {
      if (!timer_started) {
        start_time = millis();
        timer_started = true;
      } else if (millis() - start_time > 5000) { // 10000 milliseconds = 10 seconds
        PID_control = false;
        resetPID();
      }
    } else {
      timer_started = false;
      start_time = 0;
    }
  }

  else if (highTimeAux < 1900 && highTimeAux > 1880) {
    /* 
    Serial.println("video");
    delay(5000);
    For the future, this option of the transmitter would be used for AI control (ISAACS)
    */ 
  }
 
  else {
    // highTimeThr = pulseIn(inputPinThr, HIGH);
    // // Serial.print("highTimeThr: "); Serial.println(highTimeThr);

    // if (highTimeThr < minThrottle) {
    //   highTimeThr = prevThr;
    // }
    // else if (highTimeThr > maxThrottle) {
    //   highTimeThr = prevThr;
    // }

    // OCR1B = (int)map(pulse_width, minThrottle, maxThrottle, OCR1B_min, OCR1B_max);
    // unsigned long prevThr = highTimeThr; 
    OCR1B = OCR1B_min + ((float)(pulse_width - minThrottle)/(maxThrottle - minThrottle)) * (OCR1B_max - OCR1B_min);
    // Serial.print("Before Constrain: "); Serial.println(OCR1B);
    // Serial.print("pulse_width: "); Serial.println(pulse_width);
    // Serial.print("minThrottle: "); Serial.println(minThrottle);
    // Serial.print("maxThrottle: "); Serial.println(maxThrottle);
    // Serial.print("OCR1B_Max: "); Serial.println(OCR1B_max);
    // Serial.print("OCR1B_Min: "); Serial.println(OCR1B_min);
    
    OCR1B = constrain(OCR1B, OCR1B_min, OCR1B_max);
    OCR1B = constrain(OCR1B, OCR1B_min, 3150);
    // Serial.print("OCR1B"); Serial.println(OCR1B);
    // Serial.print("OCR1B_min"); Serial.println(OCR1B_min);
    // Serial.print("OCR1B_max"); Serial.println(OCR1B_max);
    // Serial.print("maxThrottle"); Serial.println(maxThrottle);
    // Serial.print("minThrottle"); Serial.println(minThrottle);
    // Serial.print("Pulse width: ");
    // Serial.print(pulse_width);
    // Serial.println(" microseconds");
    delay(500);
  }
}

// Pinout:
// 1: GND
// 2: HE #1
// 3: HE #2
// 4: HE #3 
// 5: Temp Sensor
// 6: 5V
  
// On the 3 Channel Switch (AUX Channel)— modal control
// If the A button is pressed, the car goes into PID control
// If the 3 channel switch is in neutral, the transmitter acts like a normal remote control 
// Future: If the B button is pressed, AI can control the car